name: CD
run-name: ${{ github.actor }} is running the CD ‚öôÔ∏è
on:
  # Triggers the CD pipeline whenever code is pushed to the main branch
  # This typically happens when a PR is merged or commits are pushed directly
  push:
    branches:
      - main

jobs:
  # First job: Run build, lint, and test checks before deployment
  # Reuses a shared workflow to ensure code quality and functionality
  build-lint-test:
    uses: ./.github/workflows/build-lint-test.yml
    with: 
      flutter-version: 'stable'
  
  # Second job: Build and deploy the Flutter app to Google Cloud Run
  # Only runs if build-lint-test job succeeds
  deploy-cloud-run:
    runs-on: ubuntu-latest
    needs: build-lint-test
    steps:
      # Step 1: Check out the repository code to the runner
      - name: Check out repository code 
        uses: actions/checkout@v4
        
      # Step 2: Authenticate with Google Cloud Platform using service account credentials
      # Uses Workload Identity Federation for secure, keyless authentication
      # Falls back to service account key JSON stored in GitHub Secrets
      - name: Authenticate with GCP 
        uses: google-github-actions/auth@v1
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}
      
      # Step 3: Configure the default GCP project for all subsequent gcloud commands
      # This ensures all operations target the correct project
      - name: Configure GCP Project
        run: gcloud config set project ${{ secrets.GCP_PROJECT_ID }} 
      
      # Step 4: Install Flutter SDK and make it available in the workflow
      # Uses the stable channel to ensure compatibility and reliability
      - name: Setup Flutter 
        uses: subosito/flutter-action@v2
        with:
          channel: 'stable'  

      # Step 5: Build the Flutter application for web deployment
      # Compiles Dart code to JavaScript and generates static web assets in build/web
      - name: Build flutter app for web üõú
        run: flutter build web

      # Step 6: Build Docker image and push to Google Artifact Registry
      # - Configures Docker to authenticate with GCP registries
      # - Reads version number from app-version file for image tagging
      # - Builds containerized app using Dockerfile (nginx serving Flutter web build)
      # - Pushes the versioned image to Artifact Registry for deployment
      # - Image name includes group number for unique identification
      - name: Build and Push Docker Image üê≥
        run: |
          gcloud auth configure-docker --quiet
          gcloud auth configure-docker europe-west3-docker.pkg.dev --quiet
          # Build docker image
          IMAGE=europe-west3-docker.pkg.dev/${{ secrets.GCP_PROJECT_ID }}/${{ secrets.GCP_ARTIFACT_REGISTRY }}/flutter-app-runner-group-${{ vars.GROUP_NUMBER }}:v${(1.0.11)}
          docker build -t $IMAGE .
          docker push $IMAGE




      # Step 7: Deploy the containerized app to Google Cloud Run
      # - Pulls the versioned image from Artifact Registry
      # - Deploys to us-central1 region with unique service name per group
      # - Allows unauthenticated access for public web application
      # - Cloud Run automatically handles scaling, HTTPS, and load balancing
      - name: Deploy to Cloud Run ‚òÅÔ∏è
        run: |
          # Deploy to cloud run
          gcloud run deploy flutter-workshop-group-${{ vars.GROUP_NUMBER }} \
          --image europe-west3-docker.pkg.dev/${{ secrets.GCP_PROJECT_ID }}/${{ secrets.GCP_ARTIFACT_REGISTRY }}/flutter-app-runner-group-${{ vars.GROUP_NUMBER }}:v${(1.0.11)} \
          --region us-central1 \
          --allow-unauthenticated
